import{z as ge,i as le,t as u,p as fe,b as ye,d as Pe,e as be,f as we,h as k,j as m,k as w,B as _,w as ve,s as Ee,u as pe,l as K,m as R,n as D,o as Ie,q as xe,r as y,M as G,v as te,x as X,S as Le,y as Se,A as c,C as Ae,R as A,D as Fe,E as $,F as Z,G as se,H as ze,I as re,T as ie}from"./index-DkJ5acYc.js";import{Chain as Ce,Common as O}from"./index-ByQXFTPX.js";class E{constructor(e){if(e.length!==20)throw new Error("Invalid address length");this.bytes=e}static zero(){return new E(ge(20))}static fromString(e){if(!le(e))throw new Error("Invalid address");return new E(u(e))}static fromPublicKey(e){if(!(e instanceof Uint8Array))throw new Error("Public key should be Uint8Array");const t=fe(e);return new E(t)}static fromPrivateKey(e){if(!(e instanceof Uint8Array))throw new Error("Private key should be Uint8Array");const t=ye(e);return new E(t)}static generate(e,t){if(typeof t!="bigint")throw new Error("Expected nonce to be a bigint");return new E(Pe(e.bytes,be(t)))}static generate2(e,t,s){if(!(t instanceof Uint8Array))throw new Error("Expected salt to be a Uint8Array");if(!(s instanceof Uint8Array))throw new Error("Expected initCode to be a Uint8Array");return new E(we(e.bytes,t,s))}equals(e){return k(this.bytes,e.bytes)}isZero(){return this.equals(E.zero())}isPrecompileOrSystemAddress(){const e=m(this.bytes),t=_,s=BigInt("0xffff");return e>=t&&e<=s}toString(){return w(this.bytes)}toBytes(){return new Uint8Array(this.bytes)}}const Te=ve(Ee),ke=32,q=4096,B=32*q,Ge=2,Me=B*Ge-1,Be=ke*q;function Ne(r,e){const t=new Uint8Array(e*B).fill(0);return t.set(r),t[r.byteLength]=128,t}function _e(r){const e=new Uint8Array(Be);for(let t=0;t<q;t++){const s=new Uint8Array(32);s.set(r.subarray(t*31,(t+1)*31),0),e.set(s,t*32)}return e}const Ue=r=>{const e=pe(r),t=e.byteLength;if(t===0)throw Error("invalid blob data");if(t>Me)throw Error("blob data is too large");const s=Math.ceil(t/B),i=Ne(e,s),n=[];for(let o=0;o<s;o++){const a=i.subarray(o*B,(o+1)*B),h=_e(a);n.push(h)}return n},Oe=(r,e)=>{const t=[];for(const s of e)t.push(r.blobToKzgCommitment(s));return t},$e=(r,e,t)=>e.map((i,n)=>r.computeBlobKzgProof(i,t[n])),ae=(r,e)=>{const t=new Uint8Array(32);return t.set([e],0),t.set(Te(r).subarray(1),1),t},Ve=r=>{const e=[];for(const t of r)e.push(ae(t,1));return e},He=async(r,e)=>{const t=JSON.stringify({method:e.method,params:e.params,jsonrpc:"2.0",id:1}),s=await fetch(r,{headers:{"content-type":"application/json"},method:"POST",body:t});if(!s.ok)throw new Error(`JSONRpcError: ${JSON.stringify({method:e.method,status:s.status,message:await s.text().catch(()=>"Could not parse error message likely because of a network error")},null,2)}`);return(await s.json()).result},Je=r=>{if(typeof r=="string")return r;if(typeof r=="object"&&r._getConnection!==void 0)return r._getConnection().url;throw new Error("Must provide valid provider URL or Web3Provider")};var p;(function(r){r[r.EIP155ReplayProtection=155]="EIP155ReplayProtection",r[r.EIP1559FeeMarket=1559]="EIP1559FeeMarket",r[r.EIP2718TypedTransaction=2718]="EIP2718TypedTransaction",r[r.EIP2930AccessLists=2930]="EIP2930AccessLists"})(p||(p={}));function Ke(r){if(r.length===0)return!0;const e=r[0];return!!Array.isArray(e)}function Re(r){return!Ke(r)}var l;(function(r){r[r.Legacy=0]="Legacy",r[r.AccessListEIP2930=1]="AccessListEIP2930",r[r.FeeMarketEIP1559=2]="FeeMarketEIP1559",r[r.BlobEIP4844=3]="BlobEIP4844"})(l||(l={}));function De(r){return Number(m(u(r.type)))===l.Legacy}function je(r){return Number(m(u(r.type)))===l.AccessListEIP2930}function Xe(r){return Number(m(u(r.type)))===l.FeeMarketEIP1559}function Ze(r){return Number(m(u(r.type)))===l.BlobEIP4844}function qe(r,e){const t=r.param("vm","maxInitCodeSize");if(t&&BigInt(e)>t)throw new Error(`the initcode size of this transaction is too large: it is ${e} while the max is ${r.param("vm","maxInitCodeSize")}`)}class I{static getAccessListData(e){let t,s;if(Re(e)){t=e;const i=[];for(let n=0;n<e.length;n++){const o=e[n],a=K(o.address),h=[];for(let g=0;g<o.storageKeys.length;g++)h.push(K(o.storageKeys[g]));i.push([a,h])}s=i}else{s=e??[];const i=[];for(let n=0;n<s.length;n++){const o=s[n],a=w(o[0]),h=[];for(let d=0;d<o[1].length;d++)h.push(w(o[1][d]));const g={address:a,storageKeys:h};i.push(g)}t=i}return{AccessListJSON:t,accessList:s}}static verifyAccessList(e){for(let t=0;t<e.length;t++){const s=e[t],i=s[0],n=s[1];if(s[2]!==void 0)throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");if(i.length!==20)throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");for(let o=0;o<n.length;o++)if(n[o].length!==32)throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes")}}static getAccessListJSON(e){const t=[];for(let s=0;s<e.length;s++){const i=e[s],n={address:w(R(i[0],20)),storageKeys:[]},o=i[1];for(let a=0;a<o.length;a++){const h=o[a];n.storageKeys.push(w(R(h,32)))}t.push(n)}return t}static getDataFeeEIP2930(e,t){const s=t.param("gasPrices","accessListStorageKeyCost"),i=t.param("gasPrices","accessListAddressCost");let n=0;for(let a=0;a<e.length;a++){const g=e[a][1];n+=g.length}return e.length*Number(i)+n*Number(s)}}function N(r){return K("0x"+r.toString(16).padStart(2,"0"))}class L{constructor(e,t){this.cache={hash:void 0,dataFee:void 0,senderPubKey:void 0},this.activeCapabilities=[],this.DEFAULT_CHAIN=Ce.Mainnet;const{nonce:s,gasLimit:i,to:n,value:o,data:a,v:h,r:g,s:d,type:f}=e;this._type=Number(m(u(f))),this.txOptions=t;const P=u(n===""?"0x":n),v=u(h===""?"0x":h),b=u(g===""?"0x":g),M=u(d===""?"0x":d);this.nonce=m(u(s===""?"0x":s)),this.gasLimit=m(u(i===""?"0x":i)),this.to=P.length>0?new E(P):void 0,this.value=m(u(o===""?"0x":o)),this.data=u(a===""?"0x":a),this.v=v.length>0?m(v):void 0,this.r=b.length>0?m(b):void 0,this.s=M.length>0?m(M):void 0,this._validateCannotExceedMaxInteger({value:this.value,r:this.r,s:this.s}),this._validateCannotExceedMaxInteger({gasLimit:this.gasLimit},64),this._validateCannotExceedMaxInteger({nonce:this.nonce},64,!0);const U=this.to===void 0||this.to===null,me=t.allowUnlimitedInitCodeSize??!1,ee=t.common??this._getCommon();U&&ee.isActivatedEIP(3860)&&me===!1&&qe(ee,this.data.length)}get type(){return this._type}supports(e){return this.activeCapabilities.includes(e)}getValidationErrors(){const e=[];return this.isSigned()&&!this.verifySignature()&&e.push("Invalid Signature"),this.getBaseFee()>this.gasLimit&&e.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`),e}isValid(){return this.getValidationErrors().length===0}getBaseFee(){const e=this.common.param("gasPrices","tx");let t=this.getDataFee();if(e&&(t+=e),this.common.gteHardfork("homestead")&&this.toCreationAddress()){const s=this.common.param("gasPrices","txCreation");s&&(t+=s)}return t}getDataFee(){const e=this.common.param("gasPrices","txDataZero"),t=this.common.param("gasPrices","txDataNonZero");let s=_;for(let i=0;i<this.data.length;i++)this.data[i]===0?s+=e:s+=t;if((this.to===void 0||this.to===null)&&this.common.isActivatedEIP(3860)){const i=BigInt(Math.ceil(this.data.length/32)),n=this.common.param("gasPrices","initCodeWordCost")*i;s+=n}return s}toCreationAddress(){return this.to===void 0||this.to.bytes.length===0}isSigned(){const{v:e,r:t,s}=this;return!(e===void 0||t===void 0||s===void 0)}verifySignature(){try{const e=this.getSenderPublicKey();return D(e).length!==0}catch{return!1}}getSenderAddress(){return new E(Ie(this.getSenderPublicKey()))}sign(e){if(e.length!==32){const g=this._errorMsg("Private key must be 32 bytes in length.");throw new Error(g)}let t=!1;this.type===l.Legacy&&this.common.gteHardfork("spuriousDragon")&&!this.supports(p.EIP155ReplayProtection)&&(this.activeCapabilities.push(p.EIP155ReplayProtection),t=!0);const s=this.getHashedMessageToSign(),i=this.common.customCrypto?.ecsign??xe,{v:n,r:o,s:a}=i(s,e),h=this.addSignature(n,o,a,!0);if(t){const g=this.activeCapabilities.indexOf(p.EIP155ReplayProtection);g>-1&&this.activeCapabilities.splice(g,1)}return h}toJSON(){return{type:y(BigInt(this.type)),nonce:y(this.nonce),gasLimit:y(this.gasLimit),to:this.to!==void 0?this.to.toString():void 0,value:y(this.value),data:w(this.data),v:this.v!==void 0?y(this.v):void 0,r:this.r!==void 0?y(this.r):void 0,s:this.s!==void 0?y(this.s):void 0}}_getCommon(e,t){if(t!==void 0){const s=m(u(t));if(e){if(e.chainId()!==s){const i=this._errorMsg(`The chain ID does not match the chain ID of Common. Got: ${s}, expected: ${e.chainId}`);throw new Error(i)}return e.copy()}else return O.isSupportedChainId(s)?new O({chain:s}):O.custom({name:"custom-chain",networkId:s,chainId:s},{baseChain:this.DEFAULT_CHAIN})}else return e?.copy()??new O({chain:this.DEFAULT_CHAIN})}_validateCannotExceedMaxInteger(e,t=256,s=!1){for(const[i,n]of Object.entries(e))switch(t){case 64:if(s){if(n!==void 0&&n>=te){const o=this._errorMsg(`${i} cannot equal or exceed MAX_UINT64 (2^64-1), given ${n}`);throw new Error(o)}}else if(n!==void 0&&n>te){const o=this._errorMsg(`${i} cannot exceed MAX_UINT64 (2^64-1), given ${n}`);throw new Error(o)}break;case 256:if(s){if(n!==void 0&&n>=G){const o=this._errorMsg(`${i} cannot equal or exceed MAX_INTEGER (2^256-1), given ${n}`);throw new Error(o)}}else if(n!==void 0&&n>G){const o=this._errorMsg(`${i} cannot exceed MAX_INTEGER (2^256-1), given ${n}`);throw new Error(o)}break;default:{const o=this._errorMsg("unimplemented bits value");throw new Error(o)}}}static _validateNotArray(e){const t=["nonce","gasPrice","gasLimit","to","value","data","v","r","s","type","baseFee","maxFeePerGas","chainId"];for(const[s,i]of Object.entries(e))if(t.includes(s)&&Array.isArray(i))throw new Error(`${s} cannot be an array`)}_getSharedErrorPostfix(){let e="";try{e=this.isSigned()?w(this.hash()):"not available (unsigned)"}catch{e="error"}let t="";try{t=this.isSigned().toString()}catch{e="error"}let s="";try{s=this.common.hardfork()}catch{s="error"}let i=`tx type=${this.type} hash=${e} nonce=${this.nonce} value=${this.value} `;return i+=`signed=${t} hf=${s}`,i}}function ce(r,e){const t=r.maxPriorityFeePerGas,s=r.maxFeePerGas-e,n=(t<s?t:s)+e;return r.gasLimit*n+r.value}function he(r,e){if(e===void 0||e>r.maxFeePerGas)throw new Error("Tx cannot pay baseFee");const t=r.maxFeePerGas-e;return r.maxPriorityFeePerGas<t?r.maxPriorityFeePerGas:t}function F(r,e){return`${e} (${r.errorStr()})`}function de(r,e){if(r.cache.dataFee&&r.cache.dataFee.hardfork===r.common.hardfork())return r.cache.dataFee.value;const t=L.prototype.getDataFee.bind(r)()+(e??0n);return Object.isFrozen(r)&&(r.cache.dataFee={value:t,hardfork:r.common.hardfork()}),t}function V(r){if(!r.isSigned()){const t=F(r,"Cannot call hash method if transaction is not signed");throw new Error(t)}const e=r.common.customCrypto.keccak256??X;return Object.isFrozen(r)?(r.cache.hash||(r.cache.hash=e(r.serialize())),r.cache.hash):e(r.serialize())}function H(r){const{s:e}=r;if(r.common.gteHardfork("homestead")&&e!==void 0&&e>Le){const t=F(r,"Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");throw new Error(t)}}function J(r){if(r.cache.senderPubKey!==void 0)return r.cache.senderPubKey;const e=r.getMessageToVerifySignature(),{v:t,r:s,s:i}=r;H(r);try{const o=(r.common.customCrypto.ecrecover??Se)(e,t,c(s),c(i),r.supports(p.EIP155ReplayProtection)?r.common.chainId():void 0);return Object.isFrozen(r)&&(r.cache.senderPubKey=o),o}catch{const o=F(r,"Invalid Signature");throw new Error(o)}}function ue(r,e){if(e!==void 0&&e>r)throw new Error("Tx cannot pay baseFee");return e===void 0?r:r-e}function W(r){return(r.common.customCrypto.keccak256??X)(r.getMessageToSign())}function T(r,e){return Ae(N(r.type),A.encode(e??r.raw()))}function Y(r){const{v:e}=r;if(e!==void 0&&e!==_&&e!==Fe){const t=F(r,"The y-parity of the transaction should either be 0 or 1");throw new Error(t)}}function Q(r){return de(r,BigInt(I.getDataFeeEIP2930(r.accessList,r.common)))}class z extends L{constructor(e,t={}){super({...e,type:l.FeeMarketEIP1559},t);const{chainId:s,accessList:i,maxFeePerGas:n,maxPriorityFeePerGas:o}=e;if(this.common=this._getCommon(t.common,s),this.chainId=this.common.chainId(),this.common.isActivatedEIP(1559)===!1)throw new Error("EIP-1559 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([1559,2718,2930]);const a=I.getAccessListData(i??[]);if(this.accessList=a.accessList,this.AccessListJSON=a.AccessListJSON,I.verifyAccessList(this.accessList),this.maxFeePerGas=m(u(n===""?"0x":n)),this.maxPriorityFeePerGas=m(u(o===""?"0x":o)),this._validateCannotExceedMaxInteger({maxFeePerGas:this.maxFeePerGas,maxPriorityFeePerGas:this.maxPriorityFeePerGas}),L._validateNotArray(e),this.gasLimit*this.maxFeePerGas>G){const g=this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");throw new Error(g)}if(this.maxFeePerGas<this.maxPriorityFeePerGas){const g=this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");throw new Error(g)}Y(this),H(this),(t?.freeze??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new z(e,t)}static fromSerializedTx(e,t={}){if(k(e.subarray(0,1),N(l.FeeMarketEIP1559))===!1)throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${l.FeeMarketEIP1559}, received: ${w(e.subarray(0,1))}`);const s=A.decode(e.subarray(1));if(!Array.isArray(s))throw new Error("Invalid serialized tx input: must be array");return z.fromValuesArray(s,t)}static fromValuesArray(e,t={}){if(e.length!==9&&e.length!==12)throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");const[s,i,n,o,a,h,g,d,f,P,v,b]=e;return this._validateNotArray({chainId:s,v:P}),$({nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,value:g,v:P,r:v,s:b}),new z({chainId:m(s),nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,to:h,value:g,data:d,accessList:f??[],v:P!==void 0?m(P):void 0,r:v,s:b},t)}getDataFee(){return Q(this)}getEffectivePriorityFee(e){return he(this,e)}getUpfrontCost(e=_){return ce(this,e)}raw(){return[c(this.chainId),c(this.nonce),c(this.maxPriorityFeePerGas),c(this.maxFeePerGas),c(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),c(this.value),this.data,this.accessList,this.v!==void 0?c(this.v):new Uint8Array(0),this.r!==void 0?c(this.r):new Uint8Array(0),this.s!==void 0?c(this.s):new Uint8Array(0)]}serialize(){return T(this)}getMessageToSign(){return T(this,this.raw().slice(0,9))}getHashedMessageToSign(){return W(this)}hash(){return V(this)}getMessageToVerifySignature(){return this.getHashedMessageToSign()}getSenderPublicKey(){return J(this)}addSignature(e,t,s,i=!1){t=u(t),s=u(s);const n={...this.txOptions,common:this.common};return z.fromTxData({chainId:this.chainId,nonce:this.nonce,maxPriorityFeePerGas:this.maxPriorityFeePerGas,maxFeePerGas:this.maxFeePerGas,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:i?e-Z:e,r:m(t),s:m(s)},n)}toJSON(){const e=I.getAccessListJSON(this.accessList);return{...super.toJSON(),chainId:y(this.chainId),maxPriorityFeePerGas:y(this.maxPriorityFeePerGas),maxFeePerGas:y(this.maxFeePerGas),accessList:e}}errorStr(){let e=this._getSharedErrorPostfix();return e+=` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`,e}_errorMsg(e){return F(this,e)}}class C extends L{constructor(e,t={}){super({...e,type:l.AccessListEIP2930},t);const{chainId:s,accessList:i,gasPrice:n}=e;if(this.common=this._getCommon(t.common,s),this.chainId=this.common.chainId(),!this.common.isActivatedEIP(2930))throw new Error("EIP-2930 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([2718,2930]);const o=I.getAccessListData(i??[]);if(this.accessList=o.accessList,this.AccessListJSON=o.AccessListJSON,I.verifyAccessList(this.accessList),this.gasPrice=m(u(n===""?"0x":n)),this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),L._validateNotArray(e),this.gasPrice*this.gasLimit>G){const h=this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");throw new Error(h)}Y(this),H(this),(t?.freeze??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new C(e,t)}static fromSerializedTx(e,t={}){if(k(e.subarray(0,1),N(l.AccessListEIP2930))===!1)throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${l.AccessListEIP2930}, received: ${w(e.subarray(0,1))}`);const s=A.decode(Uint8Array.from(e.subarray(1)));if(!Array.isArray(s))throw new Error("Invalid serialized tx input: must be array");return C.fromValuesArray(s,t)}static fromValuesArray(e,t={}){if(e.length!==8&&e.length!==11)throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");const[s,i,n,o,a,h,g,d,f,P,v]=e;this._validateNotArray({chainId:s,v:f}),$({nonce:i,gasPrice:n,gasLimit:o,value:h,v:f,r:P,s:v});const b=[];return new C({chainId:m(s),nonce:i,gasPrice:n,gasLimit:o,to:a,value:h,data:g,accessList:d??b,v:f!==void 0?m(f):void 0,r:P,s:v},t)}getEffectivePriorityFee(e){return ue(this.gasPrice,e)}getDataFee(){return Q(this)}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}raw(){return[c(this.chainId),c(this.nonce),c(this.gasPrice),c(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),c(this.value),this.data,this.accessList,this.v!==void 0?c(this.v):new Uint8Array(0),this.r!==void 0?c(this.r):new Uint8Array(0),this.s!==void 0?c(this.s):new Uint8Array(0)]}serialize(){return T(this)}getMessageToSign(){return T(this,this.raw().slice(0,8))}getHashedMessageToSign(){return W(this)}hash(){return V(this)}getMessageToVerifySignature(){return this.getHashedMessageToSign()}getSenderPublicKey(){return J(this)}addSignature(e,t,s,i=!1){t=u(t),s=u(s);const n={...this.txOptions,common:this.common};return C.fromTxData({chainId:this.chainId,nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:i?e-Z:e,r:m(t),s:m(s)},n)}toJSON(){const e=I.getAccessListJSON(this.accessList);return{...super.toJSON(),chainId:y(this.chainId),gasPrice:y(this.gasPrice),accessList:e}}errorStr(){let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice} accessListCount=${this.accessList?.length??0}`,e}_errorMsg(e){return F(this,e)}}const ne=6,We=(r,e,t,s,i,n)=>{if(!(r.length===e.length&&e.length===t.length))throw new Error("Number of blobVersionedHashes, blobs, and commitments not all equal");if(r.length===0)throw new Error("Invalid transaction with empty blobs");let o;try{o=n.verifyBlobKzgProofBatch(e,t,s)}catch(a){throw new Error(`KZG verification of blobs fail with error=${a}`)}if(!o)throw new Error("KZG proof cannot be verified from blobs/commitments");for(let a=0;a<r.length;a++){const h=ae(t[a],i);if(!k(h,r[a]))throw new Error(`commitment for blob at index ${a} does not match versionedHash`)}};class x extends L{constructor(e,t={}){super({...e,type:l.BlobEIP4844},t);const{chainId:s,accessList:i,maxFeePerGas:n,maxPriorityFeePerGas:o,maxFeePerBlobGas:a}=e;if(this.common=this._getCommon(t.common,s),this.chainId=this.common.chainId(),this.common.isActivatedEIP(1559)===!1)throw new Error("EIP-1559 not enabled on Common");if(this.common.isActivatedEIP(4844)===!1)throw new Error("EIP-4844 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([1559,2718,2930]);const h=I.getAccessListData(i??[]);if(this.accessList=h.accessList,this.AccessListJSON=h.AccessListJSON,I.verifyAccessList(this.accessList),this.maxFeePerGas=m(u(n===""?"0x":n)),this.maxPriorityFeePerGas=m(u(o===""?"0x":o)),this._validateCannotExceedMaxInteger({maxFeePerGas:this.maxFeePerGas,maxPriorityFeePerGas:this.maxPriorityFeePerGas}),L._validateNotArray(e),this.gasLimit*this.maxFeePerGas>G){const d=this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");throw new Error(d)}if(this.maxFeePerGas<this.maxPriorityFeePerGas){const d=this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");throw new Error(d)}this.maxFeePerBlobGas=m(u((a??"")===""?"0x":a)),this.blobVersionedHashes=(e.blobVersionedHashes??[]).map(d=>u(d)),Y(this),H(this);for(const d of this.blobVersionedHashes){if(d.length!==32){const f=this._errorMsg("versioned hash is invalid length");throw new Error(f)}if(BigInt(d[0])!==this.common.param("sharding","blobCommitmentVersionKzg")){const f=this._errorMsg("versioned hash does not start with KZG commitment version");throw new Error(f)}}if(this.blobVersionedHashes.length>ne){const d=this._errorMsg(`tx can contain at most ${ne} blobs`);throw new Error(d)}else if(this.blobVersionedHashes.length===0){const d=this._errorMsg("tx should contain at least one blob");throw new Error(d)}if(this.to===void 0){const d=this._errorMsg('tx should have a "to" field and cannot be used to create contracts');throw new Error(d)}this.blobs=e.blobs?.map(d=>u(d)),this.kzgCommitments=e.kzgCommitments?.map(d=>u(d)),this.kzgProofs=e.kzgProofs?.map(d=>u(d)),(t?.freeze??!0)&&Object.freeze(this)}static fromTxData(e,t){if(t?.common?.customCrypto?.kzg===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");const s=t.common.customCrypto.kzg;if(e.blobsData!==void 0){if(e.blobs!==void 0)throw new Error("cannot have both raw blobs data and encoded blobs in constructor");if(e.kzgCommitments!==void 0)throw new Error("cannot have both raw blobs data and KZG commitments in constructor");if(e.blobVersionedHashes!==void 0)throw new Error("cannot have both raw blobs data and versioned hashes in constructor");if(e.kzgProofs!==void 0)throw new Error("cannot have both raw blobs data and KZG proofs in constructor");e.blobs=Ue(e.blobsData.reduce((i,n)=>i+n)),e.kzgCommitments=Oe(s,e.blobs),e.blobVersionedHashes=Ve(e.kzgCommitments),e.kzgProofs=$e(s,e.blobs,e.kzgCommitments)}return new x(e,t)}getEffectivePriorityFee(e){return he(this,e)}static minimalFromNetworkWrapper(e,t){if(t?.common?.customCrypto?.kzg===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");return x.fromTxData({...e,blobs:void 0,kzgCommitments:void 0,kzgProofs:void 0},t)}static fromSerializedTx(e,t={}){if(t.common?.customCrypto?.kzg===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");if(k(e.subarray(0,1),N(l.BlobEIP4844))===!1)throw new Error(`Invalid serialized tx input: not an EIP-4844 transaction (wrong tx type, expected: ${l.BlobEIP4844}, received: ${w(e.subarray(0,1))}`);const s=A.decode(e.subarray(1));if(!Array.isArray(s))throw new Error("Invalid serialized tx input: must be array");return x.fromValuesArray(s,t)}static fromValuesArray(e,t={}){if(t.common?.customCrypto?.kzg===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");if(e.length!==11&&e.length!==14)throw new Error("Invalid EIP-4844 transaction. Only expecting 11 values (for unsigned tx) or 14 values (for signed tx).");const[s,i,n,o,a,h,g,d,f,P,v,b,M,U]=e;return this._validateNotArray({chainId:s,v:b}),$({nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,value:g,maxFeePerBlobGas:P,v:b,r:M,s:U}),new x({chainId:m(s),nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,to:h,value:g,data:d,accessList:f??[],maxFeePerBlobGas:P,blobVersionedHashes:v,v:b!==void 0?m(b):void 0,r:M,s:U},t)}static fromSerializedBlobTxNetworkWrapper(e,t){if(!t||!t.common)throw new Error("common instance required to validate versioned hashes");if(t.common?.customCrypto?.kzg===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");if(k(e.subarray(0,1),N(l.BlobEIP4844))===!1)throw new Error(`Invalid serialized tx input: not an EIP-4844 transaction (wrong tx type, expected: ${l.BlobEIP4844}, received: ${w(e.subarray(0,1))}`);const s=A.decode(e.subarray(1));if(s.length!==4)throw Error("Expected 4 values in the deserialized network transaction");const[i,n,o,a]=s,h=x.fromValuesArray(i,{...t,freeze:!1});if(h.to===void 0)throw Error("BlobEIP4844Transaction can not be send without a valid `to`");const g=Number(t.common.param("sharding","blobCommitmentVersionKzg"));return We(h.blobVersionedHashes,n,o,a,g,t.common.customCrypto.kzg),h.blobs=n,h.kzgCommitments=o,h.kzgProofs=a,(t?.freeze??!0)&&Object.freeze(h),h}getDataFee(){return Q(this)}getUpfrontCost(e=_){return ce(this,e)}raw(){return[c(this.chainId),c(this.nonce),c(this.maxPriorityFeePerGas),c(this.maxFeePerGas),c(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),c(this.value),this.data,this.accessList,c(this.maxFeePerBlobGas),this.blobVersionedHashes,this.v!==void 0?c(this.v):new Uint8Array(0),this.r!==void 0?c(this.r):new Uint8Array(0),this.s!==void 0?c(this.s):new Uint8Array(0)]}serialize(){return T(this)}serializeNetworkWrapper(){if(this.blobs===void 0||this.kzgCommitments===void 0||this.kzgProofs===void 0)throw new Error("cannot serialize network wrapper without blobs, KZG commitments and KZG proofs provided");return T(this,[this.raw(),this.blobs,this.kzgCommitments,this.kzgProofs])}getMessageToSign(){return T(this,this.raw().slice(0,11))}getHashedMessageToSign(){return W(this)}hash(){return V(this)}getMessageToVerifySignature(){return this.getHashedMessageToSign()}getSenderPublicKey(){return J(this)}toJSON(){const e=I.getAccessListJSON(this.accessList);return{...super.toJSON(),chainId:y(this.chainId),maxPriorityFeePerGas:y(this.maxPriorityFeePerGas),maxFeePerGas:y(this.maxFeePerGas),accessList:e,maxFeePerBlobGas:y(this.maxFeePerBlobGas),blobVersionedHashes:this.blobVersionedHashes.map(s=>w(s))}}addSignature(e,t,s,i=!1){t=u(t),s=u(s);const n={...this.txOptions,common:this.common};return x.fromTxData({chainId:this.chainId,nonce:this.nonce,maxPriorityFeePerGas:this.maxPriorityFeePerGas,maxFeePerGas:this.maxFeePerGas,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:i?e-Z:e,r:m(t),s:m(s),maxFeePerBlobGas:this.maxFeePerBlobGas,blobVersionedHashes:this.blobVersionedHashes,blobs:this.blobs,kzgCommitments:this.kzgCommitments,kzgProofs:this.kzgProofs},n)}errorStr(){let e=this._getSharedErrorPostfix();return e+=` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`,e}_errorMsg(e){return F(this,e)}numBlobs(){return this.blobVersionedHashes.length}}function oe(r,e){const t=Number(r),s=Number(e)*2;return t===s+35||t===s+36}class S extends L{constructor(e,t={}){if(super({...e,type:l.Legacy},t),this.common=this._validateTxV(this.v,t.common),this.keccakFunction=this.common.customCrypto.keccak256??X,this.gasPrice=m(u(e.gasPrice===""?"0x":e.gasPrice)),this.gasPrice*this.gasLimit>G){const i=this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");throw new Error(i)}this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),L._validateNotArray(e),this.common.gteHardfork("spuriousDragon")&&(this.isSigned()?oe(this.v,this.common.chainId())&&this.activeCapabilities.push(p.EIP155ReplayProtection):this.activeCapabilities.push(p.EIP155ReplayProtection)),(t?.freeze??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new S(e,t)}static fromSerializedTx(e,t={}){const s=A.decode(e);if(!Array.isArray(s))throw new Error("Invalid serialized tx input. Must be array");return this.fromValuesArray(s,t)}static fromValuesArray(e,t={}){if(e.length!==6&&e.length!==9)throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");const[s,i,n,o,a,h,g,d,f]=e;return $({nonce:s,gasPrice:i,gasLimit:n,value:a,v:g,r:d,s:f}),new S({nonce:s,gasPrice:i,gasLimit:n,to:o,value:a,data:h,v:g,r:d,s:f},t)}getEffectivePriorityFee(e){return ue(this.gasPrice,e)}raw(){return[c(this.nonce),c(this.gasPrice),c(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),c(this.value),this.data,this.v!==void 0?c(this.v):new Uint8Array(0),this.r!==void 0?c(this.r):new Uint8Array(0),this.s!==void 0?c(this.s):new Uint8Array(0)]}serialize(){return A.encode(this.raw())}getMessageToSign(){const e=[c(this.nonce),c(this.gasPrice),c(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),c(this.value),this.data];return this.supports(p.EIP155ReplayProtection)&&(e.push(c(this.common.chainId())),e.push(D(u(0))),e.push(D(u(0)))),e}getHashedMessageToSign(){const e=this.getMessageToSign();return this.keccakFunction(A.encode(e))}getDataFee(){return de(this)}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}hash(){return V(this)}getMessageToVerifySignature(){if(!this.isSigned()){const e=this._errorMsg("This transaction is not signed");throw new Error(e)}return this.getHashedMessageToSign()}getSenderPublicKey(){return J(this)}addSignature(e,t,s,i=!1){t=u(t),s=u(s),i&&this.supports(p.EIP155ReplayProtection)&&(e+=this.common.chainId()*se+ze);const n={...this.txOptions,common:this.common};return S.fromTxData({nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,v:e,r:m(t),s:m(s)},n)}toJSON(){return{...super.toJSON(),gasPrice:y(this.gasPrice)}}_validateTxV(e,t){let s;const i=e!==void 0?Number(e):void 0;if(i!==void 0&&i<37&&i!==27&&i!==28)throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${i}`);if(i!==void 0&&i!==0&&(!t||t.gteHardfork("spuriousDragon"))&&i!==27&&i!==28)if(t){if(!oe(BigInt(i),t.chainId()))throw new Error(`Incompatible EIP155-based V ${i} and chain id ${t.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`)}else{let n;(i-35)%2===0?n=35:n=36,s=BigInt(i-n)/se}return this._getCommon(t,s)}errorStr(){let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice}`,e}_errorMsg(e){return F(this,e)}}const Ye=r=>{const e=Object.assign({},r);return e.gasLimit=re(e.gasLimit??e.gas,ie.BigInt),e.data=e.data===void 0?e.input:e.data,e.gasPrice=e.gasPrice!==void 0?BigInt(e.gasPrice):void 0,e.value=e.value!==void 0?BigInt(e.value):void 0,e.to=e.to!==null&&e.to!==void 0?R(u(e.to),20):null,e.v=e.v==="0x0"?"0x":e.v,e.r=e.r==="0x0"?"0x":e.r,e.s=e.s==="0x0"?"0x":e.s,(e.v!=="0x"||e.r!=="0x"||e.s!=="0x")&&(e.v=re(e.v,ie.BigInt)),e};class j{constructor(){}static fromTxData(e,t={}){if(!("type"in e)||e.type===void 0)return S.fromTxData(e,t);if(De(e))return S.fromTxData(e,t);if(je(e))return C.fromTxData(e,t);if(Xe(e))return z.fromTxData(e,t);if(Ze(e))return x.fromTxData(e,t);throw new Error(`Tx instantiation with type ${e?.type} not supported`)}static fromSerializedData(e,t={}){if(e[0]<=127)switch(e[0]){case l.AccessListEIP2930:return C.fromSerializedTx(e,t);case l.FeeMarketEIP1559:return z.fromSerializedTx(e,t);case l.BlobEIP4844:return x.fromSerializedTx(e,t);default:throw new Error(`TypedTransaction with ID ${e[0]} unknown`)}else return S.fromSerializedTx(e,t)}static fromBlockBodyData(e,t={}){if(e instanceof Uint8Array)return this.fromSerializedData(e,t);if(Array.isArray(e))return S.fromValuesArray(e,t);throw new Error("Cannot decode transaction: unknown type input")}static async fromJsonRpcProvider(e,t,s){const i=Je(e),n=await He(i,{method:"eth_getTransactionByHash",params:[t]});if(n===null)throw new Error("No data returned from provider");return j.fromRPC(n,s)}static async fromRPC(e,t={}){return j.fromTxData(Ye(e),t)}}export{C as AccessListEIP2930Transaction,x as BlobEIP4844Transaction,p as Capability,z as FeeMarketEIP1559Transaction,S as LegacyTransaction,j as TransactionFactory,l as TransactionType,Re as isAccessList,Ke as isAccessListBytes,je as isAccessListEIP2930TxData,Ze as isBlobEIP4844TxData,Xe as isFeeMarketEIP1559TxData,De as isLegacyTxData};
